#
Ternary operator

label.frame = (inPseudoEditMode) ? kLabelIndentedRect : kLabelRect;

if(inPseudoEditMode) {
 label.frame = kLabelIndentedRect;
} else {
 label.frame = kLabelRect;
}

/////////////////
// g++ options //
/////////////////

-shared
	 Produce a shared object which can then be linked with other objects to form
an executable.  Not all systems support this option.  For predictable results,
you must also specify the same set of options used for compilation (-fpic,
-fPIC, or model suboptions) when you specify this linker option.[1]


// To specify a directory to search for (binary) libraries, you just use -L:
-L/data[...]/lib

// To specify the actual library name, you use -l:
-lfoo  # (links libfoo.a or libfoo.so)

// To specify a directory to search for include files (different from libraries!) you use -I:
-I/data[...]/lib

// LD_LIBRARY_PATH
You can temporarily substitute a different library for this particular execution. In Linux, the environment variable LD_LIBRARY_PATH is a colon-separated set of directories where libraries should be searched for first, before the standard set of directories; this is useful when debugging a new library or using a nonstandard library for special purposes
LD_LIBRARY_PATH is an environment variable you set to give the run-time shared library loader (ld.so) an extra set of directories to look for when searching for shared libraries. Multiple directories can be listed, separated with a colon (:).

// 'inline' functions

// 'static' functions

////////////////////////////////////////////////////
// Difference between shared and static libraries //
Shared libraries are .so (or in Windows .dll, or in OS X .dylib) files. All the
code relating to the library is in this file, and it is referenced by programs
using it at run-time. A program using a shared library only makes reference to
the code that it uses in the shared library.

Static libraries are .a (or in Windows .lib) files. All the code relating to
the library is in this file, and it is directly linked into the program at
compile time. A program using a static library takes copies of the code that it
uses from the static library and makes it part of the program. [Windows also
has .lib files which are used to reference .dll files, but they act the same
way as the first one].

There are advantages and disadvantages in each method.

Shared libraries reduce the amount of code that is duplicated in each program
that makes use of the library, keeping the binaries small. It also allows you
to replace the shared object with one that is functionally equivalent, but may
have added performance benefits without needing to recompile the program that
makes use of it. Shared libraries will, however have a small additional cost
for the execution of the functions as well as a run-time loading cost as all
the symbols in the library need to be connected to the things they use.
Additionally, shared libraries can be loaded into an application at run-time,
which is the general mechanism for implementing binary plug-in systems.

Static libraries increase the overall size of the binary, but it means that you
don't need to carry along a copy of the library that is being used. As the code
is connected at compile time there are not any additional run-time loading
costs. The code is simply there.

Personally, I prefer shared libraries, but use static libraries when needing to
ensure that the binary does not have many external dependencies that may be
difficult to meet, such as specific versions of the C++ standard library or
specific versions of the Boost C++ library.

