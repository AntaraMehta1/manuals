// Ternary operator

label.frame = (inPseudoEditMode) ? kLabelIndentedRect : kLabelRect;

if(inPseudoEditMode) {
 label.frame = kLabelIndentedRect;
} else {
 label.frame = kLabelRect;
}

// 'inline' functions


// 'static' functions
(http://www.cprogramming.com/tutorial/statickeyword.html)
the keyword static can be used in three major contexts: inside a function,
inside a class definition, and in front of a global variable inside a file
making up a multifile program.

- the use of static inside a function is the simplest. it simply means that once
the variable has been initialized, it remains in memory until the end of the
program

- the second use of static is inside a class definition. while most variables
declared inside a class occur on an instance-by-instance basis (which is to say
that for each instance of a class, the variable can have a different value), a
static member variable has the same value in any instance of the class and
doesn't even require an instance of the class to exist. a helpful way to think
about it is to imagine that the static variables of a class contain information
essential to the making of new member objects (as though a class definition
instance, if you wanted to number your instances of a class, you could use a
static member variable to keep track of the last number used. importantly, it is
good syntax to refer to static member functions through the use of a class name
(class_name::x; rather than instance_of_class.x;). doing so helps to remind the
programmer that static member variables do not belong to a single instance of
the class and that you don't need to have a single instance of a class to use a
static member variable. as you have probably noticed, to access the static
member, you use the scope operator, ::, when you refer to it through the name of
the class.

an important detail to keep in mind when debugging or implementing a program
using a static class member is that you cannot initialize the static class
member inside of the class. in fact, if you decide to put your code in a header
file, you cannot even initialize the static variable inside of the header file;
do it in a .cpp file instead. moreover, you are required to initialize the
static class member or it will not be in scope. (the syntax is a bit weird:
"type class_name::static_variable = value".) 

- the last use of static is as a global variable inside a file of code. in this
case, the use of static indicates that source code in other files that are part
of the project cannot access the variable. only code inside the single file can
see the variable. (it's scope -- or visibility -- is limited to the file.) this
technique can be used to simulate object oriented code because it limits
visibility of a variable and thus helps avoid naming conflicts. this use of
static is a holdover from c.

////////////////////////////////////////////////////
// difference between shared and static libraries //
shared libraries are .so (or in windows .dll, or in os x .dylib) files. all the
code relating to the library is in this file, and it is referenced by programs
using it at run-time. a program using a shared library only makes reference to
the code that it uses in the shared library.

static libraries are .a (or in windows .lib) files. all the code relating to
the library is in this file, and it is directly linked into the program at
compile time. a program using a static library takes copies of the code that it
uses from the static library and makes it part of the program. [windows also
has .lib files which are used to reference .dll files, but they act the same
way as the first one].

there are advantages and disadvantages in each method.

shared libraries reduce the amount of code that is duplicated in each program
that makes use of the library, keeping the binaries small. it also allows you
to replace the shared object with one that is functionally equivalent, but may
have added performance benefits without needing to recompile the program that
makes use of it. shared libraries will, however have a small additional cost
for the execution of the functions as well as a run-time loading cost as all
the symbols in the library need to be connected to the things they use.
additionally, shared libraries can be loaded into an application at run-time,
which is the general mechanism for implementing binary plug-in systems.

static libraries increase the overall size of the binary, but it means that you
don't need to carry along a copy of the library that is being used. as the code
is connected at compile time there are not any additional run-time loading
costs. the code is simply there.

personally, i prefer shared libraries, but use static libraries when needing to
ensure that the binary does not have many external dependencies that may be
difficult to meet, such as specific versions of the c++ standard library or
specific versions of the Boost C++ library.

